# AtOffer

简记剑指offer

## 目录

* <a href="#二维数组中的查找">1. 二维数组中的查找</a>
* <a href="#字符串中的空格替换">2. 字符串中的空格替换</a>
* <a href="#从尾到头打印链表">3. 从尾到头打印链表</a>
* <a href="#重建二叉树">4. 重建二叉树</a>
* <a href="#两个栈实现队列">5. 两个栈实现队列</a>
* <a href="#旋转数组的最小数字">6. 旋转数组的最小数字</a>
* <a href="#斐波那契数列">7. 斐波那契数列</a>
* <a href="#跳台阶">8. 跳台阶</a>
* <a href="#变态跳台阶">9. 变态跳台阶</a>
* <a href="#矩形覆盖">10. 矩形覆盖</a>
* <a href="#位运算tip">位运算tip</a>
* <a href="#二进制中1的个数">11. 二进制中1的个数</a>
* <a href="#数值的整数次方">12. 数值的整数次方</a>
* <a href="#调整数组顺序使奇数位于偶数前面">13. 调整数组顺序使奇数位于偶数前面</a>
* <a href="#链表中倒数第k个结点">14. 链表中倒数第k个结点</a>
* <a href="#反转链表">15. 反转链表</a>
* <a href="#合并两个排序的列表">16. 合并两个排序的列表</a>
* <a href="#树的子结构">17. 树的子结构</a>
* <a href="#二叉树的镜像">18. 二叉树的镜像</a>
* <a href="#顺时针打印矩阵">19. 顺时针打印矩阵</a>
* <a href="#包含min函数的栈">20. 包含min函数的栈</a>
* <a href="#栈的压入、弹出序列">21. 栈的压入、弹出序列</a>
* <a href="#从上到下打印二叉树">22. 从上到下打印二叉树</a>
* <a href="#二叉搜索树的后序遍历序列">23. 二叉搜索树的后序遍历序列</a>
* <a href="#二叉树中和为某一值的路径">24. 二叉树中和为某一值的路径</a>
* <a href="#复杂链表的复制">25. 复杂链表的复制</a>
* <a href="#二叉树的前中后序遍历">二叉树的前中后序遍历</a>
* <a href="#二叉搜索树与双向链表">26. 二叉搜索树与双向链表</a>
* <a href="#字符串的排列">27. 字符串的排列</a>
* <a href="#数组中出现次数超过一半的数字">28. 数组中出现次数超过一半的数字</a>
* <a href="#红黑树,快排,堆排">红黑树,快排,堆排,合并排序</a>
* <a href="#最小的K个数">29. 最小的K个数</a>
* <a href="#连续子数组的最大和">30. 连续子数组的最大和</a>
* <a href="#整数中1出现的次数(从1到n整数中1出现的次数)">31. 整数中1出现的次数(从1到n整数中1出现的次数)</a>
* <a href="#把数组排成最小的数">32. 把数组排成最小的数</a>
* <a href="#丑数">33. 丑数</a>
* <a href="#第一个只出现依次的字符">34. 第一个只出现依次的字符</a>
* <a href="#数组中的逆序对">35. 数组中的逆序对</a>
* <a href="#两个链表的第一个公共结点">36. 两个链表的第一个公共结点</a>
* <a href="#数字在排序数组中出现的次数">37. 数字在排序数组中出现的次数</a>
* <a href="#二叉树的深度">38. 二叉树的深度</a>
* <a href="#平衡二叉树">39. 平衡二叉树</a>
* <a href="#数组中只出现一次的数字">40. 数组中只出现一次的数字</a>
* <a href="#和为S的两个数字">41. 和为S的两个数字</a>
* <a href="#和为S的连续正数序列">42. 和为S的连续正数序列</a>
* <a href="#翻转单词顺序">43. 翻转单词顺序</a>
* <a href="#左旋转字符串">44. 左旋转字符串</a>
* <a href="#扑克牌的顺子">45. 扑克牌的顺子</a>
* <a href="#圆圈中最后剩下的数字">46. 圆圈中最后剩下的数字</a>
* <a href="#求1+2+3+...+n">47. 求1+2+3+...+n</a>
* <a href="#不用加减乘除做加法">48. 不用加减乘除做加法</a>
* <a href="#把字符串转换成整数">49. 把字符串转换成整数</a>
* <a href="#数组中重复的数字">50. 数组中重复的数字</a>
* <a href="#构建乘积数组">51. 构建乘积数组</a>
* <a href="#正则表达式匹配">52. 正则表达式匹配</a>
* <a href="#表示数值的字符串">53. 表示数值的字符串</a>
* <a href="#字符流中第一个不重复的字符">54. 字符流中第一个不重复的字符</a>
* <a href="#链表中环的入口结点">55. 链表中环的入口结点</a>
* <a href="#删除链表中重复的结点">56. 删除链表中重复的结点</a>
* <a href="#二叉树的下一个结点">57. 二叉树的下一个结点</a>
* <a href="#对称的二叉树">58. 对称的二叉树</a>
* <a href="#把二叉树打印成多行">59. 把二叉树打印成多行</a>
* <a href="#按之字形顺序打印二叉树">60. 按之字形顺序打印二叉树</a>
* <a href="#序列化二叉树">61. 序列化二叉树</a>
* <a href="#二叉搜索树的第k个结点">62. 二叉搜索树的第k个结点</a>
* <a href="#数据流中的中位数">63. 数据流中的中位数</a>
* <a href="#滑动窗口的最大值">64. 滑动窗口的最大值</a>
* <a href="#矩阵中的路径">65. 矩阵中的路径</a>
* <a href="#机器人的运动范围">66. 机器人的运动范围</a>






* [学习地址1:牛客网](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
* [学习地址2:鼠标CS的博客](http://blog.csdn.net/hubeidaxuesanqi3012/article/details/74090645?locationNum=3&fps=1)
* [学习地址3:周旭龙的博客](http://www.cnblogs.com/edisonchou/p/3843287.html)








<a id="二维数组中的查找"></a>

### 1. 二维数组中的查找
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```c
#include <stdio.h>
#include <stdbool.h>

bool find(int target, int arr[3][3])
{
	int rows = 3;
	int cols = 3;
	int i = 0,j = cols-1;
	while(i < rows && j >= 0)
	{
		if (arr[i][j] == target)
			return true;
		else if (arr[i][j] > target)
			j --;
		else
			i ++;
	}
	return false;
}

int main()
{
	int arr[3][3] = {1,2,3,4,5,6,7,8,9};
	bool result = find(10,arr);
	if (result)
		printf("Existent\n");
	else
		printf("Non-existent\n");

	return 0;
}

```

<a id="字符串中的空格替换"></a>

### 2. 字符串中的空格替换

请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


void replaceSpace(char *str, int length){
    if (str == nullptr || length==0) {
        return;
    }
    int strLen = strlen(str);
    int spaceNum = 0;
    for (int i = 0; i<strLen; i++) {
        if (str[i] == ' ') {
            spaceNum++;
        }
    }
    int newStrLength = strLen+spaceNum*2;
    if (newStrLength > length) return;
    int i = strLen,j = newStrLength;
    char *tmpStr = (char *)malloc(newStrLength);
    while (i >=0 && j>=0) {
        if (str[i] == ' '){
            tmpStr[j--] = '0';
            tmpStr[j--] = '2';
            tmpStr[j--] = '%';
        }else{
            tmpStr[j--] = str[i];
        }
        i--;
    }
    str = tmpStr;
    tmpStr = nullptr;
}


int main()
{
	char *str = "We Are Happy.";
	replaceSpace(str,13+6);
	return 0;
}
```

<a id="从尾到头打印链表"></a>

### 3. 从尾到头打印链表

输入一个链表，从尾到头打印链表每个节点的值

```cpp
#include <iostream>
#include <stack>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    struct ListNode *next;
};

class Solution
{
public:
    vector<int>printListFromTail(struct ListNode* head){
        vector<int> result;
        stack<struct ListNode*>nodes;
        struct ListNode *pNode = head;
        while (pNode != NULL) {
            nodes.push(pNode);
            pNode = pNode->next;
        }
        while (!nodes.empty()) {
            pNode = nodes.top();
            if (pNode->val != -1)
            {
                result.push_back(pNode->val);
            }
            nodes.pop();
        }
        //        reverse(result.begin(), result.end());  //如果允许使用就不用上面的stack了
        return result;
    }

    ListNode *createList(){
        
        int i;
        int len;
        int val;
        
        ListNode * phead = (ListNode *)malloc(sizeof(ListNode*));
        phead->val = -1;
        ListNode *ptail = phead;
        ptail->next = NULL;
        
        len = 3;
        
        for(i = 0; i < len; i++)
        {
            printf("第 %d 个节点的数值: ",i+1);
            // scanf("%d",&val);
            val = 5;
            ListNode *pnew = (ListNode *)malloc(sizeof(ListNode*));
            pnew->val = val;
            ptail->next = pnew;
            pnew->next = NULL;
            ptail = pnew;
        }
        return phead;
    }
};

int main() {
    
    cout << "Hello, World!\n";
    
    Solution sol;
    
    ListNode *head = sol.createList();
    sol.printListFromTail(head);
    
    return 0;
}
```

<a id="重建二叉树"></a>

### 4. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

```cpp
#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x),left(NULL),right(NULL) {}
};

class Solution {
    
public:
    TreeNode* reConstructBinaryTree(vector<int>pre,vector<int>vin)
    {
        if (pre.size()==0 || vin.size()==0) {
            return NULL;
        }
        return constructTree(pre, 0, pre.size()-1, vin, 0, vin.size()-1);
    }
    TreeNode* constructTree(const vector<int>& pre,long s1,long e1,const vector<int>& vin,long s2,long e2)
    {
        long i;
        for (i=s2; i<=e2; i++) {
            if (pre[s1]==vin[i])
                break;
        }
        if (i > e2)
            return NULL;
        TreeNode* head = new TreeNode(pre[s1]);
        head->left = constructTree(pre, s1+1, s1+i-s2, vin, s2, i-1); ////s1+i-s2,i-s2是左子树的个数.前序是根左右,根后面是左子树的集合.
        head->right = constructTree(pre, s1+i-s2+1, e1, vin, i+1, e2);
        return head;
    }
};

int main(int argc, const char * argv[]) {
    vector<int>pre = {1,2,4,7,3,5,6,8};
    vector<int>vin = {4,7,2,1,5,3,8,6};
    Solution sol;
    TreeNode* head = sol.reConstructBinaryTree(pre, vin);
    return 0;
}
```

<a id="两个栈实现队列"></a>

### 5. 两个栈实现队列

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

```cpp
#include <iostream>
#include <stack>

using namespace std;

class Solution
{
public:
    void push(int node){
        stack1.push(node);
    }
    int pop(){
        if (stack2.empty()) {
            while (!stack1.empty()) {
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int res = -1;
        if (!stack2.empty()) {
            res = stack2.top();
            stack2.pop();
        }
        return res;
    }
    
private:
    stack<int> stack1;
    stack<int> stack2;
};

int main(int argc, const char * argv[]) {
    
    Solution sol;
    sol.push(1);
    sol.push(2);
    
    int a = sol.pop();
    
    return 0;
}
```

<a id="旋转数组的最小数字"></a>

### 6. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

解法1： 牛客验证通过,解法有问题


```cpp 
int Min(vector<int>&rotateArray){
    int n = rotateArray.size();
    if (n==0) return 0;
    int i = 0,j = n-1;
    int mid = (i+j)/2;
    cout << rotateArray[0] << endl;
    while (i<=j) {
        if (i == mid) {
            return rotateArray[i]>rotateArray[j]?rotateArray[j]:rotateArray[i];
        }
        // 元素都相等或者旋转数组正好旋转次数等于数组大小,等于没旋转
        else if (rotateArray[i]<=rotateArray[mid] && rotateArray[mid]<=rotateArray[j]){
            return rotateArray[i];
        }
        else if (rotateArray[j]>=rotateArray[mid]&&rotateArray[mid]<rotateArray[i]){
            j = mid;
            mid = (i+j)/2;
        }else if(rotateArray[i]<=rotateArray[mid]&&rotateArray[mid]>rotateArray[j]){
            i = mid;
            mid = (i+j)/2;
        }
    }
    return 0;
}
```

解法2：

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution{
public:
    int Min(vector<int>rotateArray)
    {
        if (rotateArray.size()==0) {
            return 0;
        }
        int i = 0,j=(int)rotateArray.size()-1;
        int mid = i;
        while (rotateArray[i] >= rotateArray[j]) { // 保证旋转性质
            if (j-i==1) {
                mid = j;
                break;
            }
            mid = (i+j)/2;
            //如果i,j,mid指向的数相等,则只能顺序查找
            if (rotateArray[i]==rotateArray[mid]&&rotateArray[mid]==rotateArray[j]) {
                return MinInOrder(rotateArray, i, j);
            }
            if (rotateArray[mid]>=rotateArray[i]) {
                i = mid;
            }
            else if (rotateArray[mid]<rotateArray[j])
            {
                j = mid;
            }
        }
        return rotateArray[mid];
    }
    
    int MinInOrder(const vector<int>rotateArray,int start,int end)
    {
        int min = rotateArray[start];
        for (int i=start+1; i<=end; i++)
        {
            if (rotateArray[i]<min) {
                min = rotateArray[i];
            }
        }
        return min;
    }
};

int main(int argc, const char * argv[]) {
    Solution sol;
    vector<int> rotateArray = {3,4,5,1,2};
    int result = sol.Min(rotateArray);
    return 0;
}
```

<a id="斐波那契数列"></a>

### 7. 斐波那契数列

现在要求输入一个整数n，请你输出斐波那契数列的第n项。n<=39

```cpp
class Solution{
public:
    int Fibonacci(int n){
        if (n<2)
            return n;
        int a = 0,b = 1;
        int c = 0;
        for (int i = 2; i<=n; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
};

int main(int argc, const char * argv[]) {
    
    Solution sol;
    int reuslt = sol.Fibonacci(39);
    
    return 0;
}
```

<a id="跳台阶"></a>

### 8. 跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法

```cpp
/*
 如果n级为f(n)
 当n>2时,如果第一次跳一级,则剩下的n-1为f(n-1)
 如果第一次跳两级,则剩下的为f(n-2)
 则f(n)=f(n-1)+f(n-2)
 */

class Solution{
public:
    int jumpFloor(int number){
        if (number==1)
            return 1;
        else if (number==2)
            return 2;
        int a = 1,b = 2,c = 3;
        for (int i = 3; i <=number; i++) {
            c = a+b;
            a = b;
            b = c;
        }
        return c;
    }
};

int main(int argc, const char * argv[]) {
    Solution sol;
    int result = sol.jumpFloor(10);
    return 0;
}
```

<a id="变态跳台阶"></a>

### 9. 变态跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法

```cpp
#include <iostream>

class Solution {
public:
    int jumpFloorII(int number) {
        // f(n) = 2^(n-1)
        // 1左移(number-1)相当2^(n-1)
        return 1 << (number -1);
    }
};

int main(int argc, const char * argv[]) {
    
    Solution sol;
    int result = sol.jumpFloorII(10);
    
    return 0;
}

```

<a id="矩形覆盖"></a>

### 10. 矩形覆盖

我们可以用`2*1`的小矩形横着或者竖着去覆盖更大的矩形。请问用n个`2*1`的小矩形无重叠地覆盖一个`2*n`的大矩形，总共有多少种方法

解析：用第一个1×2小矩形去覆盖大矩形的最左边时有两个选择，竖着放和横着放，当竖着放时右边还剩下2×(n-1)的区域，这种情况下的覆盖方法记为f(n-1)
当横着放在左上角的时候，左下角必须横着放一个1×2的小矩形，而右边还剩下2×6的区域，这种情况下的覆盖方法记为f(n-2)

```cpp
#include <iostream>

class Solution {
public:
    int rectCover(int number) {
        if(number <= 2)
            return number;
        int a = 1, b = 2;
        int c = 3;
        for(int i=3; i<=number; i++)
        {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
};

int main(int argc, const char * argv[]) {
    
    Solution sol;
    int result = sol.rectCover(10);
    return 0;
}
```

<a id="位运算tip"></a>


### 位运算tip

* **原码**:最高位表示符号位,1位负,0为正.其他为存二进制的绝对值.`1010为-2`
* **反码**:**正数**的反码还是等于原码.**负数**的反码就是他的原码除符号位外,安位取反.例:3当反码与原码相同,则可以表示为0011.-3的原码是1011,反码为1100
* 补码:**正数**的补码等于他的原码.**负数**的补码等于反码+1.
* 负数的补码=模-负数的绝对值.例:10000(模为2^4=16)-0100=1100(-4的补码)
* 左移:左边移出的部分丢弃,右边补0. `00001010<<2=00101000`,`10001010<<3=01010000`
* 正数右移:左边补0.`00001010>>2=00000010`
* 负数右移:左边补1.`10001010>>3=11110001`
* 把正数右移一位和把正数除以2在数学上都是等价的,但是位运算比乘除法效率高很多

### 取反操作

* 计算a的补码
	* 先计算a补码,得到b
	* b按位取反,得到c
	* c是某个数的原码,这个原码就是所求
* 取反就是先获得补码,补码按位取反,
* 计算机只识别补码

```
~12     12取反
				     0000 1100
取反后  			   1111 0011  它是一个负数的补码
减1后				   1111 0010
除符号位外按位取反	  1000 1101  是-13
所以 ~12 为 -13


~-12    -12取反
					   1000 1100
补码				     1111 0100
按位取反			   0000 1011 是11
```


<a id="二进制中1的个数"></a>

### 11. 二进制中1的个数

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示

```cpp
//解法1
class Solution1{
public:
    int NumberOf1(int n){
        int count = 0;
        unsigned int flag = 1;
        while (flag) {
            //将类似0001,0010,0100,...(应该为32位)和n做位与运算,如果不为0,则n的该位为1
            if (n & flag) {
                count ++;
            }
            //32位的整数要循环32次,
            //当左移后超出32位则1存在寄存器进位器中,剩下部分为0,跳出循环
            flag = flag << 1;
        }
        return count;
    }
};

//解法2: 1100,减1后为1011,1100和1011做与运算为1000,相当将最右边的1取反为0.
class Solution2{
public:
    int NumberOf1(int n){
        int count = 0;
        while (n) {
            count++;
            n = (n-1) & n;
        }
        return count;
    }
};
```

<a id="数值的整数次方"></a>

### 12. 数值的整数次方

推荐解法:

每次折半,效率更高

[http://blog.longpengfei.com/post/50-pow/](http://blog.longpengfei.com/post/50-pow/)

```cpp
double myPow(double x,int n){
    if (n==0) return 1;
    double half = myPow(x, n/2);
    if (n%2==0) {
        return half*half;
    }
    if (n>0) {
        return half*half*x;
    }
    return half*half/x;
}
```

下面解法效率没上面高


解法1: 再看一次的解法,牛客网验证通过

```cpp
double  Power(double base,int exponent){
	if (base==0&&exponent<0) return 0;
	if (base==0) return 0;
	bool flag1 = base>0?true:false;
	bool flag2 = exponent>0?true:false;
	double abs_base = flag1?base:-base;
	int abs_exponent = flag2?exponent:-exponent;
	double tmp = 1;
	while (abs_exponent>0) {
	    tmp *= abs_base;
	    abs_exponent--;
	}
	tmp = flag2 ? tmp : 1.0 / tmp;
	tmp = flag1 ? tmp : -tmp;
	return tmp;
}
```

解法2: 

```cpp
class Solution{
public:
    double Power(double base,int exponent)
    {
        if (equal(base, 0.0) && exponent < 0) {
            return 0.0;
        }
        unsigned int absExponent = abs(exponent);
        double result = PowerWithUnsignedExponent(base, absExponent);
        if (exponent<0) {
            result = 1.0/result;
        }
        return result;
    }
    
    bool equal(double num1,double num2)
    {
        if (num1-num2 < 0.0000001 && num1-num2 > -0.0000001)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    
    double PowerWithUnsignedExponent(double base,unsigned int exponent)
    {
        if (exponent==0) {
            return 1;
        }
        else if (exponent==1)
        {
            return base;
        }
        double result = PowerWithUnsignedExponent(base,exponent>>1);
        result *= result;
        //判断奇偶 位运算判断奇偶比取余效率高,奇数左移1位后相当除2,所以还有余数1
        if((exponent & 0x1) == 1)
        {
            result *= base;
        }
        return result;
    }
};
```

<a id="调整数组顺序使奇数位于偶数前面"></a>

### 13. 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变

一次遍历,空间复杂度为O(1)

```cpp
void reOrderArray(vector<int>&array){
    int i=0,j=0;
    int size = array.size();
    while (i<size&&j<size) {
        while (i<size&&array[i]%2==1) {
            i++;
        }
        if (j<=i) j = i+1;
        if (j >= size) return;
        while (j<size&&array[j]%2==0) {
            j++;
        }
        if (j>=size) return;
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
        i++;
        j++;
    }
}
```

解法1: 一次遍历,牛客网验证通过

```cpp
void reOrderArray(vector<int>&array){
    if (array.size()==0) return;
    vector<int> tmp{};
    int j = 0;
    for (int i=0; i<array.size(); i++) {
        // 奇数
        if (array[i]&1) {
            tmp.insert(tmp.begin()+j++, array[i]);
        }else{
            tmp.push_back(array[i]);
        }
    }
    array = tmp;
}
```

解法2: 

```cpp
class Solution{
public:
    void reOrderArray(vector<int>array){
        int n = (int)array.size();
        if(n <= 1)
            return;
        vector<int>tmp;
        for (int i = 0; i<n; i++) {
            //奇数
            if (array[i] & 0x1) {
                tmp.push_back(array[i]);
            }
        }
        for (int i = 0; i<n; i++) {
            //偶数
            if ((array[i] & 0x1)==0) {
                tmp.push_back(array[i]);
            }
        }
        array = tmp;
    }
};
```

<a id="链表中倒数第k个结点"></a>

### 14. 链表中倒数第k个结点

输入一个链表，输出该链表中倒数第k个结点

```cpp
struct ListNode{
    int val;
    struct ListNode* next;
    ListNode(int x):
    val(x),next(NULL){
    }
};

class Solution{
public:
    ListNode* FindKthToTail(ListNode* pListHead,unsigned int k){
        if (pListHead == NULL || k == 0)
        {
            return NULL;
        }
        ListNode* pFast = pListHead;
        ListNode* pSlow = pListHead;
        for (unsigned int i = 0; i < k-1; i++)
        {
            if (pFast->next==NULL)
            {
                return NULL;
            }
            pFast = pFast->next;
        }
        while (pFast->next!=NULL)
        {
            pSlow = pSlow->next;
            pFast = pFast->next;
        }
        return pSlow;
    }
};
```

<a id="反转链表"></a>

### 15. 反转链表

输入一个链表，反转链表后，输出链表的所有元素

```cpp
struct ListNode {
    int val;
    struct ListNode* next;
    ListNode(int x):
    val(x),next(NULL){
    }
};

class Solution{
public:
    ListNode* ReverseList(ListNode* pHead){
        ListNode* pre = NULL;
        ListNode* p = pHead;
        ListNode* pn = NULL;
        
        while (p) {
            pn = p->next;
            p->next = pre;
            pre = p;
            p = pn;
        }
        return pre;
    }
};

```

<a id="合并两个排序的列表"></a>

### 16. 合并两个排序的列表

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则

解法1:

```cpp
ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
{
    if (pHead1==NULL) return pHead2;
    if (pHead2==NULL) return pHead1;
    ListNode *res = new ListNode(-1);
    ListNode *n = res;
    while (pHead1 && pHead2) {
        if (pHead1->val<pHead2->val){
            n->next = pHead1;
            n = n->next;
            pHead1 = pHead1->next;
        }else{
            n->next = pHead2;
            n = n->next;
            pHead2 = pHead2->next;
        }
    }
    if(pHead1==NULL){
        n->next = pHead2;
    }
    if (pHead2==NULL) {
        n->next = pHead1;
    }
    n = res;
    res = res->next;
    delete n;
    return res;
}
```

解法2: 

```cpp
struct ListNode{
    int val;
    struct ListNode* next;
    ListNode(int x):
        val(x),next(NULL){
    }
};

class Solution{
public:
    ListNode* Merge(ListNode* pHead1,ListNode* pHead2)
    {
        if (pHead1 == NULL)
            return pHead2;
        else if (pHead2==NULL)
            return pHead1;
        ListNode* newHead = NULL;
        if (pHead1->val<pHead2->val)
        {
            newHead = pHead1;
            newHead->next = Merge(pHead1->next, pHead2);
        }
        else
        {
            newHead = pHead2;
            newHead->next = Merge(pHead1, pHead2->next);
        }
        return newHead;
    }
};
```

<a id="树的子结构"></a>

### 17. 树的子结构

```cpp
/*
 step1: 在树A中找到和B的根结点一样的结点R
 step2: 判断树A中以R为根结点的子树是不是包含和树B一样的结构
 这是一个递归的过程
 */

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){}
};

class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1,TreeNode* pRoot2)
    {
        if (pRoot1 == NULL || pRoot2 == NULL)
            return false;
        bool res = false;
        if (pRoot1->val == pRoot2->val)
            res = IsSubtree(pRoot1, pRoot2);
        if (!res)
            res = HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2);
        return res;
    }
    
    bool IsSubtree(TreeNode* pRoot1,TreeNode* pRoot2)
    {
        if (pRoot2 == NULL)
            return true;
        if (pRoot1 == NULL)
            return false;
        if (pRoot1->val != pRoot2->val)
            return false;
        return IsSubtree(pRoot1->left, pRoot2->left) && IsSubtree(pRoot1->right, pRoot2->right);
    }
};
```

<a id="二叉树的镜像"></a>

### 18. 二叉树的镜像

跟 <a href="#对称的二叉树">58题 对称的二叉树</a> 有点像

```cpp
struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){};
};

class Solution {
public:
    void Mirror(TreeNode* pRoot)
    {
        if (pRoot == NULL)
            return;
        TreeNode* tmp = pRoot->left;
        pRoot->left = pRoot->right;
        pRoot->right = tmp;
        if (pRoot->left)
            Mirror(pRoot->left);
        if (pRoot->right)
            Mirror(pRoot->right);
    }
};

非递归解法
class Solution {
 public:
 void Mirror(TreeNode *pRoot) {
    if(pRoot==NULL) return;
    // 这里用queue也是可以的 牛客上验证过
    stack<TreeNode*> s;
    s.push(pRoot);
    while(!s.empty())
     {
         TreeNode *head = s.top();
         s.pop();
         if(head->left||head->right)
         {
             TreeNode *tmp = head->left;
             head->left = head->right;
             head->right = tmp;
         }
         if (head->left) s.push(head->left);
         if (head->right) s.push(head->right);
      }
    }
};

```

<a id="顺时针打印矩阵"></a>

### 19. 顺时针打印矩阵

解法1:

```cpp
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
        vector<int> result;
        vector<vector<int> >  tmp = matrix;
        while(tmp.size() >= 1)
        {
            vector<int> r = tmp[0];
            for(int i = 0;i<r.size();i++){
                result.push_back(r[i]);
            }
            tmp.erase(tmp.begin());
            if (tmp.size()>0) {
                tmp = reverseMatrix(tmp);
            }
            else{
                break;
            }
        }
        return result;
    }
    
    vector<vector<int>> reverseMatrix(vector<vector<int>> matrix){
        int rows = matrix.size();
        int cols = matrix[0].size();
        vector<vector<int>> result;
        for (int i = cols-1;i >= 0;i--)
        {
            vector<int> r;
            for (int j = 0;j<rows;j++)
            {
                r.push_back(matrix[j][i]);
            }
            result.push_back(r);
        }
        return result;
    }
};
```

解法2:

```cpp
class Solution2 {
public:
    vector<int> printMatrix(vector<vector<int>> matrix){
        vector<int> res;
        int rows = matrix.size();
        int cols = matrix[0].size();
        if (rows==0||cols==0) {
            return res;
        }
        int left = 0,top = 0;
        int right = cols-1,bottom = rows-1;
        while (top<=bottom && left <= right)
        {
            int i,j;
            for (j=left;j<=right;j++)
                res.push_back(matrix[top][j]);
            for (i = top+1;i<=bottom;i++)
                res.push_back(matrix[i][right]);
            if (top < bottom) {
                for(j=right-1;j>left;j--)
                    res.push_back(matrix[bottom][j]);
            }
            if (left<right) {
                for (i=bottom;i>top;i--)
                    res.push_back(matrix[i][left]);
            }
            top++;
            left++;
            right--;
            bottom--;
            
        }
        return res;
    }
};
```

<a id="包含min函数的栈"></a>

### 20. 包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数

```cpp
#include <stack>
using namespace std;

class Solution {
private:
    stack<int> s1,s2;
public:
    void push(int value) {
        if (s1.size()>0 && s2.top()<value)
        {
            s2.push(s2.top());
        }
        else
        {
            s2.push(value);
        }
        s1.push(value);
    }
    void pop() {
        s1.pop();
        s2.pop();
    }
    int top() {
        return s1.top();
    }
    int min() {
        return s2.top();
    }
};
```

<a id="栈的压入、弹出序列"><a>

### 21. 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列  4, 5, 3, 2, 1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

```cpp
#include <vector>
#include <stack>

using namespace std;

class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        
        stack<int> st;
        
        for (int i = 0,j=0; i < pushV.size(); )
        {
            st.push(pushV[i++]);
            while (j<popV.size() && st.top()==popV[j])
            {
                st.pop();
                j++;
            }
        }
        return st.empty();
    }
};
```

<a id="从上到下打印二叉树"></a>

### 22. 从上到下打印二叉树

从上往下打印出二叉树的每个节点，同层节点从左至右打印

```cpp
#include <vector>
#include <queue>

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){
            
        }
};

class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root)
    {
        vector<int> result;
        if (root==NULL)
            return result;
        queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty())
        {
            TreeNode* node = q.front();
            result.push_back(node->val);
            q.pop();
            if (node->left)
            {
                q.push(node->left);
            }
            if (node->right)
            {
                q.push(node->right);
            }
        }
        return result;
    }
};
```

<a id="二叉搜索树的后序遍历序列"></a>

### 23. 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同

在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，它们都比根结点的值小；第二部分是右子树结点的值，它们都比根结点的值大。

因此，我们可以总结出算法步骤：

　　Step1.通过取出序列最后一个元素得到二叉搜索树的根节点；

　　Step2.在二叉搜索树中左子树的结点小于根结点，因此可以遍历一次得到左子树；

　　Step3.在二叉搜索树中右子树的结点大于根结点，因此可以继续遍历后序元素得到右子树；

　　Step4.重复以上步骤递归判断左右子树是不是二叉搜索树，如果都是，则返回true，如果不是，则返回false;

下面两种写法思路大体相同,如上面的分析

写法1:

```cpp
bool VerifySquenceOfBST(vector<int> sequence){
    if (sequence.size()<=1) return true;
    return verifySquence(sequence, 0, sequence.size()-1);
}
//  4,8,6,12,16,14,10
bool verifySquence(vector<int> sequence,int begin,int end){
    if (begin<end) {
        int root = sequence[end];
        int leftIndex = begin;
        int leftBegin = begin;
        while (begin < end && sequence[begin]<root) {
            begin++;
        }
        leftIndex = begin-1;
        while (begin<end && sequence[begin]>root) {
            begin++;
        }
        if (begin==end) {
            return verifySquence(sequence, leftBegin, leftIndex)&&verifySquence(sequence, leftIndex+1, end-1);
        }else{
            return false;
        }
    }
    return true;
}
```

写法2: 

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        if (sequence.size() == 0)
            return false;
        return VerifyBST(sequence, 0, (int)sequence.size()-1);
    }
    
    bool VerifyBST(vector<int> sequence,int start,int end)
    {
        int i,j;
        for (i=start;i<end;i++)
        {
            if (sequence[i] > sequence[end])
                break;
        }
        j = i - 1;
        while (i < end)
        {
            if (sequence[i] < sequence[end])
                return false;
            i++;
        }
        bool left = true;
        if (j > start)
            left = VerifyBST(sequence, start, j);
        bool right = true;
        if (j+1 < end-1)
            right = VerifyBST(sequence, j+1, end-1);
        return left && right;
    }
};
```

<a id="二叉树中和为某一值的路径"></a>

### 24. 二叉树中和为某一值的路径

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径

```cpp
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){
        }
};

class Solution {
public:
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
        vector<vector<int>> res;
        if (root == NULL)
            return res;
        vector<int> solution;
        findPath(root, expectNumber, solution, res);
        return res;
    }
    void findPath(TreeNode* root,int expectNumber,vector<int>& solution,vector<vector<int>>&res)
    {
        int sum = expectNumber - root->val;
        solution.push_back(root->val);
        //判断是否为叶结点,并且sum是否加满了
        if (root->left == NULL && root->right==NULL && sum==0)
        {
            res.push_back(solution);
        }
        if (root->left)
            findPath(root->left, sum, solution, res);
        if (root->right)
            findPath(root->right, sum, solution, res);
        //往后推一个
        solution.pop_back();
    }
};
```

<a id="复杂链表的复制"></a>

### 25. 复杂链表的复制

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

```cpp
#include <map>

using namespace std;

struct RandomListNode {
    int label;
    struct RandomListNode* next,* random;
    RandomListNode(int x):
        label(x),next(NULL),random(NULL){
    }
};

/*
 方法1:
 复制原始链表上的每个节点N创建N',然后把这些创建出来的结点用next连接起来,
 A-->B-->C-->D
 A'->B'->C'->D'.
 同时把<N,N'>的配对信息放一个哈希表中.
 然后设置复制链表中的每个结点的random指针,如果原始列表中的N的random指向的结点为S,
 那么在赋值链表中,对应的N'应该指向S'.
 时间复杂度: O(N)
 */

typedef map<RandomListNode*,RandomListNode*> MAP;

class Solution1 {
public:
    
    RandomListNode* CloneNodes(RandomListNode* pHead,MAP &hashNode)
    {
        RandomListNode* pNode = new RandomListNode(0);
        RandomListNode* p = pNode;
        RandomListNode* tmp;
        while (pHead != NULL) {
            tmp = new RandomListNode(0);
            tmp->label = pHead->label;
            p->next = tmp;
            hashNode[pHead] = tmp;
            pHead = pHead->next;
            p=p->next; //就是当前的tmp
        }
        return pNode->next;
    }
    
    void setRandomNodes(RandomListNode* pHead,RandomListNode* pCopy,MAP &hashNode)
    {
        while (pCopy!=NULL) {
            pCopy->random = hashNode[pHead->random];
            pCopy = pCopy->next;
            pHead = pHead->next;
        }
    }
    
    RandomListNode* Clone(RandomListNode* pHead)
    {
        RandomListNode* pCopy;
        MAP hashNode;
        pCopy = CloneNodes(pHead, hashNode);
        setRandomNodes(pHead, pCopy, hashNode);
        return pCopy;
    }
};

/*
 方法2
 在不使用辅助空间的情况下实现O(N)的时间效率
 第一步：根据原始链表的每个结点N创建对应的N',然后将N‘通过pNext接到N的后面
 第二步：设置复制出来的结点的random,假设原始链表上的N的random指向结点S,那么其对应复制出来的N'是N->pNext指向的结点,同样S'也是结点S->pNext指向的结点
 第三步：把长链表拆分成两个链表,把奇数位置的结点用pNext连接起来的就是原始链表,把偶数位置的结点通过pNext连接起来的就是复制链表
 */

class Solution2{
    
    void CloneNodes(RandomListNode* pHead)
    {
        RandomListNode* pNode = pHead;
        RandomListNode* pCloned;
        while (pNode!=NULL) {
            pCloned = new RandomListNode(pNode->label);
            pCloned->next = pNode->next;
            pNode->next = pCloned;
            pNode = pCloned->next;
        }
    }
    
    void ConnectRandomNodes(RandomListNode* pHead)
    {
        RandomListNode* pNode = pHead;
        RandomListNode* pCloned;
        while (pNode!=NULL) {
            pCloned = pNode->next;
            if (pNode->random!=NULL) {
                pCloned->random = pNode->random->next;
            }
            pNode=pCloned->next;
        }
    }
    
    RandomListNode* ReconnectNodes(RandomListNode* pHead)
    {
        RandomListNode* pNode = pHead;
        RandomListNode* pClonedHead = NULL;
        RandomListNode* pClonedNode = NULL;
        if (pNode!=NULL) {
            pClonedHead = pClonedNode = pNode->next;
            pNode->next = pClonedNode->next;
            pNode = pNode->next;
        }
        while (pNode!=NULL) {
            pClonedNode->next=pNode->next;
            pClonedNode=pClonedNode->next;
            pNode->next=pClonedNode->next;
            pNode = pNode->next;
        }
        return pClonedHead;
    }
    
    RandomListNode* Clone(RandomListNode* pHead)
    {
        CloneNodes(pHead);
        ConnectRandomNodes(pHead);
        return ReconnectNodes(pHead);
    }
};
```

<a id="二叉树的前中后序遍历"></a>


### 二叉树的前中后序遍历

* 前序遍历：根节点->左子树->右子树
* 中序遍历：左子树->根节点->右子树
* 后序遍历：左子树->右子树->根节点

```cpp
#include <vector>
#include <stack>

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x) :
        val(x),left(NULL),right(NULL){}
};


//前序递归遍历
vector<int> preVector;
void PreOrder(TreeNode* root)
{
    if (root != NULL)
    {
        preVector.push_back(root->val);
        PreOrder(root->left);
        PreOrder(root->right);
    }
}

//前序非递归遍历
void PreOrder2(TreeNode* root)
{
    stack<TreeNode*> s;
    TreeNode* p = root;
    vector<int> result;
    while (p || !s.empty())
    {
        if (p)
        {
            result.push_back(p->val);
            s.push(p);
            p = p->left;
        }
        else
        {
            p = s.top();
            p = p->right;
            s.pop();
        }
    }
}

//中序递归遍历
vector<int> inResult;
void InOrder(TreeNode* root)
{
    if (root != NULL) {
	    //遍历左子树： 调用 InOrder(root->left) 递归地遍历左子树。这确保了左子树的所有节点都会在当前节点之前被访问。
        InOrder(root->left);
        //处理当前节点： 将当前节点的值 root->val 加入结果向量 inResult。由于这是中序遍历，当前节点的值会在左子树的节点之后，右子树的节点之前加入结果
        inResult.push_back(root->val);
        //遍历右子树： 调用 InOrder(root->right) 递归地遍历右子树。这确保了右子树的所有节点都会在当前节点之后被访问。
        InOrder(root->right);
    }
}

//中序非递归遍历
void InOrder2(TreeNode* root)
{
    stack<TreeNode*> s;
    vector<int> result;
    TreeNode* p = root;
    while (p || !s.empty())
    {
        if (p)
        {
            s.push(p);
            p = p->left;
        }
        else
        {
            p = s.top();
            result.push_back(p->val);
            s.pop();
            p = p->right;
        }
    }
}

//后序递归遍历
vector<int> postResult;
void PostOrder(TreeNode* root)
{
    if (root != NULL)
    {
        PostOrder(root->left);
        PostOrder(root->right);
        postResult.push_back(root->val);
    }
}

//后序非递归遍历
void PostOrder2(TreeNode* root)
{
    stack<TreeNode*> s;
    vector<int> result;
    TreeNode* p = root;
    TreeNode* r = NULL; //  用于记录上一个访问过的节点
    while (p || !s.empty())
    {
        //走到最左边
        if (p)
        {
        	// 将当前节点入栈，并移动到左子树
            s.push(p);
            p = p->left;
        }
        else
        {
            //取栈顶结点
            p  = s.top();
            // 如果存在右子树且右子树未被访问过，移动到右子树
            if (p->right&&p->right!=r)
            {
                p = p->right;
                s.push(p);
                //在走到最左
                p = p->left;
            }
            // 否则，表示左右子树都已经访问过，将当前节点值加入结果向量
            else
            {
                result.push_back(p->val);
                // 记录当前节点已被访问
                r = p;
                s.pop();
                //将p置为NULL，以便继续回溯到父节点
                p = NULL;
            }
        }
    }
}
```



<a id="二叉搜索树与双向链表"></a>

### 26. 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向

二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。

下面两种写法思路差不多,写法1更好点,都通过

写法1: 

```cpp
TreeNode* Convert(TreeNode* pRootOfTree){
    if (pRootOfTree==NULL) return  NULL;
    vector<TreeNode *> array{};
    stack<TreeNode *> s{};
    TreeNode *p = pRootOfTree;
    while (p || !s.empty()) {
        if (p) {
            s.push(p);
            p = p->left;
        }else{
            p = s.top();
            array.push_back(p);
            p = p->right;
            s.pop();
        }
    }
    TreeNode *pre = NULL;
    for (int i=0; i<array.size(); i++) {
        p = array[i];
        p->left = pre;
        if(i!=0) pre->right = p;
        pre = p;
    }
    p->right = NULL;
    return array[0];
}
```

写法2:


```cpp

#include <vector>
#include <stack>
using namespace std;
struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x) :
        val(x),left(NULL),right(NULL){}
};

class Solution {
public:
    
    //中序遍历后为排序结果
    void Order(TreeNode* root,vector<TreeNode*>& result)
    {
        if (root != NULL) {
            Order(root->left,result);
            result.push_back(root);
            Order(root->right,result);
        }
    }
    
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if (pRootOfTree == NULL) {
            return NULL;
        }
        vector<TreeNode*> result;
        Order(pRootOfTree, result);
        TreeNode* tmp;
        for (int i = 0;i < result.size();i++)
        {
            if (i != 0)
            {
                TreeNode* p = result[i];
                tmp->right = p;
                p->left = tmp;
            }
            tmp = result[i];
        }
        return result[0];
    }
};
```

<a id="字符串的排列"></a>

### 27. 字符串的排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。

例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 

输入描述:  输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母

```cpp
#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    
    void Permutation2(string& str,int k,int n,vector<string>& res)
    {
        if (k==n) {
            res.push_back(str);
            return;
        }
        for (int i = k; i < n; i++) {
            if (str[i] == str[k] && i != k)
                continue;
            swap(str[k], str[i]);
            Permutation2(str, k+1, n, res);
            swap(str[k], str[i]);
        }
    }
    
    vector<string> Permutation(string str){
        vector<string> res;
        int n = str.length();
        if (n == 0)
            return res;
        Permutation2(str, 0, n, res);
        sort(res.begin(), res.end());
        return res;
    }
};
```

<a id="数组中出现次数超过一半的数字"></a>

### 28. 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字.

例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。

由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。

如果不存在则输出0

```cpp
#include <vector>
#include <map>

using namespace std;
typedef map<int,int> MAP;

class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers)
    {
        MAP hashInt;
        for (int i = 0; i < numbers.size(); i++) {
            hashInt[numbers[i]] = hashInt.find(numbers[i])==hashInt.end()?1:hashInt[numbers[i]]+1;
        }
        MAP::iterator it = hashInt.begin();
        int max = it->second;
        int key = it->first;
        while (it != hashInt.end()) {
            if (it->second > max)
            {
                max = it->second;
                key = it->first;
            }
            it++;
        }
        if (max > numbers.size()/2)
        {
            return key;
        }
        return 0;
    }
};

class Solution2 {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers)
    {
        int res = 0;
        int count = 0;
        //找到数量最多的数字
        for (int i = 0;i < numbers.size();i++)
        {
            if (count == 0)
            {
                res = numbers[i];
                count++;
            }
            else if(numbers[i] == res)
            {
                count++;
            }
            else
            {
                count--;
            }
        }
        if (res)
        {
            count = 0;
            for (int i = 0; i < numbers.size(); i++) {
                if (numbers[i] == res)
                    count++;
            }
            if (count * 2 <= numbers.size())
                res = 0;
        }
        return res;
    }
};
```

<a id="红黑树,快排,堆排,合并排序"></a>

### 红黑树,快排,堆排,合并排序

[红黑树](https://www.cnblogs.com/skywang12345/p/3245399.html)

[快排](https://baike.baidu.com/item/快速排序算法/369842?fr=aladdin)

[堆排](https://www.cnblogs.com/jingmoxukong/p/4303826.html)

<a id="最小的K个数"></a>

**合并排序**

```cpp
//将有二个有序数列a[first...mid]和a[mid...last]合并
void mergearray(int a[],int first,int mid,int last,int temp[])
{
	int i = first,j = mid+1;
	int m = mid,n = last;
	int k = 0;
	while (i<=m && j <= n)
	{
		if (a[i]<=a[j])
			temp[k++] = a[i++];
		else
			temp[k++] = a[j++];
		// printf("%d\n", temp[k]);
	}
	while (i <= m)
		temp[k++] = a[i++];
	while (j <= n)
		temp[k++] = a[j++];
	for (int i = 0; i < k; ++i)
		a[first+i] = temp[i];
}


void mergesort(int a[],int first,int last,int temp[])
{
	if (first<last)
	{
		int mid = (first+last)/2;
		mergesort(a,first,mid,temp);
		mergesort(a,mid+1,last,temp);
		mergearray(a,first,mid,last,temp);
	}
}

void MergeSort(int a[],int n)
{
	int *p = new int[n];
	if (p == NULL) return;
	mergesort(a,0,n-1,p);
	delete[] p;
}
```

### 29. 最小的K个数

输入n个整数，找出其中最小的K个数。

例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4

```cpp
#include <vector>
#include <set>
using namespace std;
/*
 解法1:
 运用快排的思想
 把数组的元素分成两组,右边比左边的都要大
 数据都读到内存,并且修改数组
 */
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int>input,int k)
    {
        vector<int> res;
        int n = input.size();
        if (n == 0 || k > n || k <= 0) {
            return res;
        }
        int start = 0,end = n-1;
        int mid = partition(input, start, end);
        while (mid != k-1)
        {
            if (mid > k-1)
            {
                end = mid - 1;
                mid = partition(input, start, end);
            }
            else
            {
                start = mid + 1;
                mid = partition(input, start, end);
            }
        }
        for (int i = 0; i < k; i++) {
            res.push_back(input[i]);
        }
        return res;
    }
    
    int partition(vector<int>& input,int start,int end)
    {
        int key = input[start];
        while (start < end)
        {
            while (start < end && input[end] >= key)
                end --;
            input[start] = input[end];
            while (start < end && input[start] <= key)
                start++;
            input[end] = input[start];
        }
        input[start] = key;
        return start;
    }
};
/*
 解法2
 用大根堆的思想
 这里用multiset(内部红黑树,查找快(Ologn))保存k个元素,greater排序保证首个元素为最大
 k个元素之后每个与multiset首个元素比较
 适合海量数据,不修改原数组,修改都在multiset中
 */
class Solution2 {
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k)
    {
        int n = input.size();
        if (n == 0 || n < k || k <= 0)
            return vector<int>();
        multiset<int,greater<int>> leastNumbers;
        for (int i = 0;i < n;i++)
        {
            if (i < k)
                leastNumbers.insert(input[i]);
            else
            {
                multiset<int,greater<int>> ::const_iterator iter = leastNumbers.begin();
                if (*iter > input[i]) {
                    leastNumbers.erase(iter);
                    leastNumbers.insert(input[i]);
                }
            }
        }
        vector<int> res(leastNumbers.begin(),leastNumbers.end());
        return res;
    }
};
```

<a id="连续子数组的最大和"></a>

### 30. 连续子数组的最大和

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8 ( 从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int>array)
    {
        int n = (int)array.size();
        if (n == 0)
            return 0;
        int maxSum = INT_MIN;
        int sum = 0;
        for (int i = 0; i < n; i++)
        {
            if (sum <= 0)
                sum = array[i];
            else
                sum += array[i];
            if (sum > maxSum)
                maxSum = sum;
        }
        return maxSum;
    }
};
```

<a id="整数中1出现的次数(从1到n整数中1出现的次数)"></a>

### 31. 整数中1出现的次数(从1到n整数中1出现的次数)

求出`1~13`的整数中1出现的次数,并算出`100~1300`的整数中1出现的次数？为此他特别数了一下`1~13`中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数

```cpp
/*
 以534为例:
 个位中1出现的次数为53*1+1
 十位中1出现的次数为5*10+10
 百位中1出现的次数为0*100+100
 
 以514为例:
 个位中1出现的次数为53*1+1
 十位中1出现的次数为5*10+4+1 (5*10为0~500,4+1为501~514中十位为1,因为510十位有1)
 百位中1出现的次数为0*100+100
 */

class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        if (n < 1)
            return 0;
        int count = 0;
        int base = 1;
        int round = n;
        while (round > 0) {
            int weight = round%10;
            round /= 10;
            count += base*round;
            if (weight==1)
                count += (n%base)+1;
            else if(weight>1)
                count += base;
            base *= 10;
        }
        return count;
    }
};
```

<a id="把数组排成最小的数"></a>

### 32. 把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323

```cpp
#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    string PrintMinNumber(vector<int> numbers)
    {
        vector<string> strNum;
        for (int i = 0; i < numbers.size(); i++)
        {
            string s = to_string(numbers[i]);
            strNum.push_back(s);
        }
        sort(strNum.begin(), strNum.end(), cmp);
        string res = "";
        for (int i = 0;i < strNum.size();i++)
            res += strNum[i];
        return res;;
    }
    
    static bool cmp(const string s1,const string s2)
    {
        string num1 = s1 + s2;
        string num2 = s2 + s1;
        return num1 < num2;
    }
};
```

<a id="丑数"></a>

### 33. 丑数

把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数

```cpp
#include <vector>

using namespace std;

class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        if (index <= 0)
            return 0;
        int i = 1;
        int two = 0;
        int three = 0;
        int five = 0;
        vector<int> ugly(index,0);
        ugly[0] = 1;
        while (i < index)
        {
            ugly[i] = min(min(ugly[two]*2, ugly[three]*3), ugly[five]*5);
            while (ugly[two]*2 <= ugly[i])
                two++;
            while (ugly[three]*3 <= ugly[i])
                three++;
            while (ugly[five]*5 <= ugly[i])
                five++;
            i++;
        }
        return ugly[index-1];
    }
};
```

<a id="第一个只出现依次的字符"></a>

### 34. 第一个只出现依次的字符

在一个字符串(1<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置

```cpp
#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        //由于字符(char)是一个长度为8的数据类型,因此总共有可能256种可能.
        vector<int> num(256,0);
        int n = (int)str.length();
        if (n == 0)
            return -1;
        for (int i = 0; i < n; i++)
        {
            int c = str[i];
            num[c] ++;
        }
        int res = -1;
        for (int i = 0 ; i < n; i++)
        {
            if (num[str[i]] == 1)
            {
                res = i;
                break;
            }
        }
        return res;
    }
};
```

<a id="数组中的逆序对"></a>

### 35. 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 

**输入描述**:题目保证输入的数组中没有的相同的数字
 
**数据范围：**

对于%50的数据,size<=10^4
        
对于%75的数据,size<=10^5
        
对于%100的数据,size<=2*10^5
    
解法1:

解法1用的就是常写的归并排序方法,验证通过

```cpp
int InversePairs(vector<int> data) {
    int count = 0;
    int n = data.size();
    int *a = new int[n]{0};
    for (int i=0;i<data.size();i++){
        a[i] = data[i];
    }
    MergeSort(a,data.size(),count);
    return count;
}
    
void mergearray(int a[],int low,int mid,int high,int tmp[],int &count){
    int i = low,j = mid+1;
    int m = mid,n = high;
    int k = 0;
    while(i<=m&&j<=n){
        if (a[i] <= a[j])
        {
            tmp[k++] = a[i++];
        }
        else
        {
        	//当a[j]<a[i]时候,因为a[i]到a[mid]之间是有序的.所以i到mid之间倒是逆序对
            count += (mid-i+1);
            count %= 1000000007;
            tmp[k++] = a[j++];
        }
    }
    while(i<=m) tmp[k++] = a[i++];
    while(j<=n) tmp[k++] = a[j++];
    for (i=0;i<k;i++)
        a[low+i] = tmp[i];
}
    
void mergesort(int a[],int low,int high,int tmp[],int &count){
    if (low < high)
    {
        int mid = (low+high)/2;
        mergesort(a,low,mid,tmp,count);
        mergesort(a,mid+1,high,tmp,count);
        mergearray(a,low,mid,high,tmp,count);
    }
}
    
void MergeSort(int a[],int n,int &count){
    int *tmp = new int[n]{};
    int low = 0,high = n-1;
    mergesort(a,low,high,tmp,count);
    delete[] tmp;
}
```


解法2:    

    
```cpp
/*
 归并排序
 1. 先按顺序拆成一个个
 2. 相邻的比较并计数,比较后排序成小->大(正序)
 3. 相邻的两两比较并排序,比较后排序(4个数正序)
 3. 相邻两组比较(每组4个)...
 */
#include <vector>
using namespace std;
class Solution {
public:
    int InversePairs(vector<int> data) {
        int n = (int)data.size();
        if (n==0)
            return 0;
        int count = 0;
        MergeSort(data, 0, n-1, count);
        return count % 1000000007;
    }
    void MergeSort(vector<int>& data,int start,int end,int& count)
    {
        if (start < end)
        {
            int mid = (start + end)/2;
            MergeSort(data, start, mid, count);
            MergeSort(data, mid+1, end, count);
            Merge(data, start, mid, mid+1, end, count);
        }
    }
    void Merge(vector<int>& data,int lbegin,int lend,int rbegin,int rend,int& count)
    {
        int i = lend,j = rend;
        int n = rend - lbegin + 1;
        int k = n - 1 ;
        vector<int> tmp(n,0);
        while (i >= lbegin && j >= rbegin)
        {
            if (data[i] > data[j])
            {
                count += j - rbegin + 1;
                count %= 1000000007;
                tmp[k] = data[i];
                k--;
                i--;
            }
            else
            {
                tmp[k] = data[j];
                k--;
                j--;
            }
        }
        while (i >= lbegin)
        {
            tmp[k] = data[i];
            k--;
            i--;
        }
        while (j >= rbegin)
        {
            tmp[k] = data[j];
            k--;
            j--;
        }
        for (i = lbegin,k = 0; i <= rend; i++,k++)
        {
            data[i] = tmp[k];
        }
    }
};
```        

<a id="两个链表的第一个公共结点"></a>

### 36. 两个链表的第一个公共结点

输入两个链表，找出它们的第一个公共结点

```cpp
/*
 因为每个节点只有一个next结点,所以如果有公共结点,那从改结点后都为相同结点
 呈现为Y形状
 */

#include <iostream>

struct ListNode {
    int val;
    struct ListNode* next;
    ListNode(int x) :
    val(x),next(NULL) {}
};

class Solution {
public:
    ListNode* FindFirstCommonNode(ListNode* pHead1,ListNode* pHead2)
    {
        if (pHead1 == NULL || pHead2 == NULL) {
            return NULL;
        }
        int len1 = getLength(pHead1);
        int len2 = getLength(pHead2);
        int dist = 0;
        ListNode* pLong = NULL;
        ListNode* pShort = NULL;
        if (len1 > len2) {
            pLong = pHead1;
            pShort = pHead2;
            dist = len1 - len2;
        }
        else
        {
            pLong = pHead2;
            pShort = pHead1;
            dist = len2 - len1;
        }
        for (int i = 0; i<dist;i++)
        {
            pLong = pLong->next;
        }
        while (pLong)
        {
            if (pLong->val==pShort->val) {
                return pLong;
            }
            pLong = pLong->next;
            pShort = pShort->next;
        }
        return NULL;
    }
    
    int getLength(ListNode* head)
    {
        ListNode* p = head;
        int count = 0;
        while (p) {
            count ++;
            p = p->next;
        }
        return count;
    }
};
```

<a id="数字在排序数组中出现的次数"></a>

### 37. 数字在排序数组中出现的次数

统计一个数字在排序数组中出现的次数

解法1:

```cpp
int GetNumberOfK(vector<int>data, int k){
    int size = data.size();
    if (size==0) return 0;
    int first = 0,last = size-1;
    int mid = (first+last)/2;
    while (first<last&&data[mid]!=k) {
        if (data[mid]>k){
            last = mid-1;
        }else{
            first = mid+1;w
        }
        mid = (first+last)/2;
    }
    if (data[mid]!=k) return 0;
    int count = 1;
    int index = mid-1;
    while (index>=0&&data[index]==k) {
        count++;
        index--;
    }
    index = mid+1;
    while (index<size&&data[index]==k) {
        count++;
        index++;
    }
    
    return count;
}
```


解法2:


```cpp
/*
 因为有序数组,想到二分查找
 修改二分查找
 因为可能有重复出现
 找到左边的第一个索引和右边的最后一个索引即可
 */

#include <vector>
using namespace std;
class Solution {
public:
    int GetNumberOfK(vector<int>data, int k)
    {
        int n = (int)data.size();
        if (n == 0)
            return 0;
        int left = leftEqual(data, k);
        int right = rightEqual(data, k);
        if (left!=-1&&right!=-1)
            return right-left+1;
        return 0;
    }
    
    int leftEqual(vector<int>& data,int k)
    {
        int left = 0,right = (int)data.size()-1;
        int mid;
        while (left <= right)
        {
            mid = (left+right) / 2;
            if (data[mid]==k)
            {
                if (mid==left || (mid-1>=left && data[mid-1] != k))
                    return mid;
                right = mid - 1;
            }
            else if (data[mid]>k)
                right = mid - 1;
            else
                left = mid + 1;
        }
        return  -1;
    }
    
    int rightEqual(vector<int>& data,int k)
    {
        int left = 0,right=(int)data.size()-1;
        int mid;
        while (left <= right) {
            mid = (left+right)/2;
            if (data[mid]==k) {
                if (mid == right || (mid+1 <= right && data[mid+1] != k))
                    return mid;
                left = mid + 1;
            }
            else if(data[mid] > k)
                right = mid - 1;
            else
                left = mid + 1;
        }
        return -1;
    }
};
```

<a id="二叉树的深度"></a>


### 38. 二叉树的深度

输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度


解法1: 高富帅解法,利用前序遍历的解法,非递归.验证通过

```cpp
int TreeDepth2(TreeNode* pRoot){
    if (pRoot==NULL) return 0;
    int count = 0;
    int res = 0;
    TreeNode *p = pRoot;
    stack<TreeNode *> s{};
    while (p || !s.empty()) {
        if (p) {
            s.push(p);
            count ++;
            if (count>res) {
                res = count;
            }
            p = p->left;
        }else{
            p = s.top();
            cout << p->val;
            if(p->val==10){
                cout << "0";
            }
            p = p->right;
            s.pop();
            // 当有右结点的时候不应该减1操作.
            if (!p)
                count--;
        }
    }
    return res;
}
```

解法2:


```cpp
#include <algorithm>
using namespace std;
struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){
            
        }
};

class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if (pRoot == NULL)
            return 0;
        int left = 0;
        int right = 0;
        if (pRoot->left)
            left = TreeDepth(pRoot->left);
        if (pRoot->right)
            right = TreeDepth(pRoot->right);
        return 1 + max(left, right);
    }
};
```

<a id="平衡二叉树"></a>

### 39. 平衡二叉树

输入一棵二叉树，判断该二叉树是否是平衡二叉树

```cpp

/**
 平衡二叉树,左右字数都是平衡二叉树
 左右字数深度最多相差1
*/

#include <iostream>

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){
            
        }
};

class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot){
        if (pRoot == NULL)
            return true;
        int depth = 0;
        return Balance(pRoot, depth);
    }
    
    //后序遍历保证每个结点只被遍历一次
    bool Balance(TreeNode* pRoot,int& depth)
    {
        if (pRoot == NULL)
            return true;
        int left = 0,right = 0;
        if (Balance(pRoot->left, left) && Balance(pRoot->right, right))
        {
            int dif = left - right;
            if (dif >= -1 && dif <= 1)
            {
                depth = left > right ? left + 1 : right + 1;
                return true;
            }
        }
        return false;
    }
};
```

<a id="数组中只出现一次的数字"></a>

### 40. 数组中只出现一次的数字

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字


```
/**
 两个相同的数异或为0,0异或5等于5
 先对数组中每个数进行异或,将得到的数的第一个为1的位作为分割位n,
 再对原数组分组,以分割位n的0,1分为两个子数组
 例:{2,4,3,6,3,2,5,5}
 1. 0^=2^=4^=3^=6^=3^=2^=5^=5 = 010
 2. 再以分割位的0或者1进行分组,得到{2,3,6,3,2},{4,5,5}
 因为4和6的倒数第二位不一样,所以以倒数第二位分组
 所以在对两个子数组分别从头到尾异或运算分别得到6和4
 */
```

下面的解法都是上面的分析的思路

解法1: 验证通过

```cpp
void FindNumsAppearOnce(vector<int>data,int* num1,int* num2){
    int n = data.size();
    int oriBit = 0;
    for (int i=0; i<n; i++) {
        oriBit ^= data[i];
    }
    if (oriBit==0) return;
    int c = 0; //记录右移几次
    while ((oriBit&1)!=1) {
        oriBit = oriBit >> 1;
        c ++;
    }
    int bit = 1;
    while (c--) {
        bit *= 2;
    }
    *num1 = 0;
    *num2 = 0;
    for (int i=0; i<n; i++) {
        int num = data[i];
        if ((num&bit)==bit){
            *num1 ^= data[i];
        }else{
            *num2 ^= data[i];
        }
    }
}
```


解法2: 


```cpp


#include <vector>

using namespace std;

class Solution {
public:
    void FindNumsAppearOnce(vector<int>data,int* num1,int* num2)
    {
        int n = (int)data.size();
        if(n==0||n<2)
            return;
        int res = 0;
        *num1 = 0;
        *num2 = 0;
        for (int i = 0;i < n;i++)
            res ^= data[i];
        int k = firstBit(res);
        for (int i = 0; i < n; i ++)
        {
            if (IsEqualOne(data[i], k))
            {
                *num1 ^= data[i];
            }
            else
            {
                *num2 ^= data[i];
            }
        }
    }
    
    int firstBit(int res)
    {
        int count = 0;
        while ((res & 0x1)==0 && (count < 8 * sizeof(int)))
        {
            res >>= 1;
            count ++;
        }
        return count;
    }
    bool IsEqualOne(int num,int k)
    {
        return (num >> k) & 0x1;
    }
};
```

<a id="和为S的两个数字"></a>

### 41. 和为S的两个数字

输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

输出描述：对应每个测试案例，输出两个数，小的先输出

```cpp
/*
 两个指针从数组两侧遍历相加比较
 */

#include <vector>
using namespace std;

class Solution {
public:
    vector<int> FindNumbersWithSum(vector<int> array,int sum)
    {
        int n = (int)array.size();
        if (n == 0 || n < 2)
            return vector<int>();
        vector<int> res;
        int small = 0,big = n - 1;
        while (small < big)
        {
            int curSum = array[small] + array[big];
            if (curSum == sum)
            {
                res.push_back(array[small]);
                res.push_back(array[big]);
                break;
            }
            else if (curSum > sum)
                big --;
            else
                small ++;
        }
        return res;
    }
};
```

<a id="和为S的连续正数序列"></a>

### 42. 和为S的连续正数序列

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

输出描述：输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序

```cpp
/*
 small=1,big=2开始.
 如果等于S.从small到big进行for加和.
 如果比S大,减去small并把small前进一位
 如果比S小,big前进一位并加big
 */

#include <vector>
using namespace std;

class Solution {
public:
    vector<vector<int> > FindContinuousSequence(int sum) {
        vector<vector<int>> res;
        if (sum <= 0)
            return res;
        int start = 1,end = 2;
        int curSum = start + end;
        vector<int> solution;
        while (start <= sum/2)
        {
            if (curSum == sum)
            {
                for (int i = start;i <= end;i ++)
                    solution.push_back(i);
                res.push_back(solution);
                solution.clear();
                end++;
                curSum += end;
            }
            else if (curSum > sum)
            {
                curSum -= start;
                start++;
            }
            else
            {
                end ++;
                curSum += end;
            }
        }
        return res;
    }
};
```

<a id="翻转单词顺序"></a>

### 43. 翻转单词顺序

牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？

下面两个写法思路一样,只看写法1即可

写法1:

```cpp
string ReverseSentence(string str){
    int size = (int)str.size();
    if (size<=1) return str;
    ReverseString(str, 0, size-1);
    int begin = 0,end = 0;
    bool hasSpace = false;
    for (int i=1; i<size; i++) {
        if (str[i]==' '){
            hasSpace = true;
            end = i-1;
            ReverseString(str, begin, end);
            begin = i+1;
        }
        if (i == size-1) {
            end = size-1;
            ReverseString(str, begin, end);
        }
    }
    return str;
}

void ReverseString(string &str,int beign,int end){
    if (beign>=end) return;
    for (int i = 0; i<(end+1-beign)/2; i++) {
        char tmp = str[beign+i];
        str[beign+i] = str[end-i];
        str[end-i] = tmp;
    }
}
```

写法2: 

```cpp
#include <string>

using namespace std;

class Solution {
public:
    string ReverseSentence(string str) {
        int length = (int)str.length();
        if (length == 0)
            return str;
        Reverse(str, 0, length-1);
        int start = 0;
        int end = 0;
        for (int i = 0;i < length;i++)
        {
            if (str[i] == ' ')
            {
                end = i - 1;
                Reverse(str, start, end);
                start = i + 1;
            }
            if (i == length -1)
            {
                end = i;
                Reverse(str, start, end);
            }
        }
        return str;
    }
    
    void Reverse(string& str,int start,int end)
    {
        while (start < end)
        {
            char tmp = str[start];
            str[start] = str[end];
            str[end] = tmp;
            start++;
            end --;
        }
    }
};
```

<a id="左旋转字符串"></a>

### 44. 左旋转字符串

汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

解法1: 先计算出每个字符对应的索引,再赋值字符串. 验证通过

```cpp
string LeftRotateString(string str, int n){
    int size = (int)str.size();
    if (n<=0||size==0) return str;
    n %= size; // 需要注意下 size如果等于0,会出浮点错误,跟除0一样
    if (n==0) return str;
    string res = string(str);
    int k = 0; //原来字符串中的字符 在最终 结果中的 索引
    for (int i=0; i<size; i++) {
        if (i>=n) {
            k = i-n;
            res[k] = str[i];
        }else{
            k = size - (n-i);
            res[k] = str[i];
        }
    }
    return res;
}
```

解法2 : 两次翻转字符串

```cpp
/*
 例:'helloworld' => 'worldhello'
 可以先翻转前一部分,再翻转后一部分,最后在翻转整个字符串即可
 1. 'ollehworld'
 2. 'ollehdlrow'
 3. 'worldhello'
 */

#include <string>
using namespace std;
class Solution {
public:
    string LeftRotateString(string str, int n)
    {
        int length = (int)str.length();
        if (length == 0 || n < 0)
            return str;
        n %= length;
        
        Reverse(str, 0, n-1);
        Reverse(str, n, length-1);
        Reverse(str, 0, length-1);
        return str;
    }
    
    void Reverse(string& str,int start,int end)
    {
        while (start < end)
        {
            char tmp = str[start];
            str[start] = str[end];
            str[end] = tmp;
            start ++;
            end --;
        }
    }
};
```

<a id="扑克牌的顺子"></a>

### 45. 扑克牌的顺子

LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    bool IsContinuous( vector<int> numbers )
    {
        int n = (int)numbers.size();
        if (n == 0)
            return false;
        sort(numbers.begin(), numbers.end());
        int zero = 0;
        int dif = 0;
        for (int i = 0; i < n;i++)
        {
            if (numbers[i] == 0)
                zero++;
            else if (i+1 < n)
            {
                //如果含有对子,则不是顺子
                if (numbers[i]==numbers[i+1])
                    return false;
                dif += numbers[i+1] - numbers[i] - 1;
            }
        }
        if (zero >= dif)
            return true;
        return false;
    }
};
```

<a id="圆圈中最后剩下的数字"></a>

### 46. 圆圈中最后剩下的数字

0,1,...,n-1这n个数字排成一个圆圈,从数字0开始每次从这个圆圈里删除第m个数字.
求出这个圆圈里剩下的最后一个数字

解法1: 解法2相对思路更清晰些,解法1验证通过

```cpp
int LastRemaining_Solution(int n, int m){
    if (n<1||m<1) return -1;
    bool *bs =  new bool[n](); //存储哪个被砍掉
    int k = n,i = 0; //k 记录砍掉几个
    int tmp = 1;     //m 记录到第几个
    while (k>1) {
        while (tmp!=m) {
            if (bs[i]) i++;
            else{
                i++;
                tmp++;
            }
            if (i==n) i = 0;
            while (bs[i]) {
                i++;
                if (i==n) i=0;
            }
        }
        cout << i << endl;
        bs[i] = true;
        k--;
        while (bs[i]) {
            i++;
            if (i==n) i=0;
        }
        if (i==n) i = 0;
        tmp = 1;
    }
    for (i=0; i<n; i++) {
        if (!bs[i]) return i;
    }
    delete[] bs;
    return -1;
}
```

解法2: 


```cpp
#include <list>
#include <iostream>
using namespace std;

class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if (n < 1 || m < 1)
            return -1;
        list<int> numbers;
        int i = 0;
        for (;i < n;i++)
            numbers.push_back(i);
        list<int>::iterator iter = numbers.begin();
        while (numbers.size() > 1)
        {
            for (i = 1; i < m ;i++)
            {
                iter++;
                if (iter == numbers.end())
                    iter = numbers.begin();
            }
            
            list<int>::iterator next = ++iter;
            --iter;
            numbers.erase(iter);
            iter = next;
            if (iter == numbers.end())
                iter = numbers.begin();
        }
        return *iter;
    }
};
```

<a id="求1+2+3+...+n"></a>

### 47. 求1+2+3+...+n

求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）

```cpp
/*
 // 方法一: 利用构造函数
class A
{
public:
    A()
    {
        ++i;
        sum += i;
    }
    static int getsum()
    {
        return sum;
    }
    static void reset()
    {
        i = 0;
        sum = 0;
    }
    
private:
    static int i ;
    static int sum;
};

int A::i = 0;
int A::sum = 0;

class Solution{
public:
    int Sum_Solution(int n)
    {
        A::reset();
        A* a = new A[n];
        int res = A::getsum();
        delete[] a;
        return res;
    }
};

//方法二: 利用虚函数
class A;
A* array[2];

class A
{
public:
    virtual int sum(int n)
    {
        return 0;
    }
};
class B: public A
{
public:
    virtual int sum(int n)
    {
        return ::array[!!n]->sum(n-1)+n;
    }
};

class Solution
{
public:
    int Sum_Solution(int n)
    {
        A a;
        B b;
        ::array[0] = &a;
        ::array[1] = &b;
        
        return ::array[1]->sum(n);
    }
};

```

<a id="不用加减乘除做加法"></a>

### 48. 不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号

```cpp
/*
 对于数字除了四则运算只能用位运算了
 两个整数之和可分解两个数相加(不带进位)+进位,5+17=5+7+10=2+10(进位)+10=22
 二进制不带进位的相加可看做异或
 进位可用与运算的结果左移一位表示
 */


class Solution
{
public:
    int Add(int num1,int num2)
    {
        int sum,carray;
        do
        {
            sum = num1 ^ num2;
            carray = (num1 & num2) << 1;
            
            num1 = sum;
            num2 = carray;
        }while (carray);
        return sum;
    }
};
```

<a id="把字符串转换成整数"></a>


### 49. 把字符串转换成整数

将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 

输入描述：输入一个字符串,包括数字字母符号,可以为空

输出描述：如果是合法的数值表达则返回该数字，否则返回0

下面写法差不多,看一个即可

写法1: 

```cpp
int StrToInt(string str){
    int n = (int)str.size();
    if (n<=0 || (n==1&&(str[0]=='-'||str[1]=='+'))) return 0;
    bool isNeg = false;
    int res = 0;
    for (int i=0; i<n; i++) {
        char c = str[i];
        if (i==0){
            if (c=='-'){
                isNeg = true;
            }else if(c=='+'){
                continue;
            }else if(c>'0'&&c<='9'){
                res += (c-'0');
            }else{
                return 0;
            }
        }else{
            if (c>='0'&&c<='9'){
                res = res*10+(c-'0');
            }else{
                return 0;
            }
        }
    }
    return isNeg?-res:res;
}
```

写法2:

```cpp
#include <string>
using namespace std;
class Solution
{
public:
    int StrToInt(string str)
    {
        int length = (int)str.length();
        if (length == 0)
            return 0;
        int res = 0;
        bool flag = false;
        for (int i = 0; i < length; i++)
        {
            if (i == 0 && str[i] == '-')
                flag = true;
            else if (i == 0 && str[i]== '+')
                continue;
            else if (str[i] >= '0' && str[i] <= '9')
            {
                res = res*10+str[i]-'0';
                if ((!flag && res > 0x7FFFFFFF)||(flag && -res < 0x80000000))
                    return 0;
            }
            else
                return 0;
        }
        if (flag)
            res *= -1;
        return res;
    }
    
};
```


<a id="数组中重复的数字"></a>

### 50. 数组中重复的数字

在一个长度为n的数组里的所有数字都在0到n-1的范围内。

数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2

```cpp
/**
 方法1: 先排序(快,堆),后遍历一遍  时间复杂度O(nlogn)  空间复杂度O(1)
 方法2: 用哈希表存,取 比较  时间O(n) 空间O(n)
 方法3: 遍历数组,假设第i个位置的数字为j,比较下标j的位置数字相同则直接返回,否则交换j到下标为j的位置.下标i之前的数为0到i-1.
        如果第i个位置小于i则直接返回结果
        时间O(n),空间O(1)
 */

class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    //        Return value: true if the input is valid, and there are some duplications in the array number
    //         otherwise false
    bool duplicate(int numbers[], int length, int* duplication) {
        if (numbers == NULL ||length == 0)
            return false;
        int i = 0;
        for (i = 0;i < length;i++)
        {
            if (numbers[i] < 0 || numbers[i] > length - 1)
                return false;
        }
        i = 0;
        while (i < length)
        {
            if (numbers[i] == i)
                i++;
            else if (numbers[i] > i)
            {
                if (numbers[i] == numbers[numbers[i]])
                {
                    *duplication = numbers[i];
                    return true;
                }
                swap(numbers[i], numbers[numbers[i]]);
            }
            else
            {
                *duplication = numbers[i];
                return true;
            }
        }
        return false;
    }
};
```

<a id="构建乘积数组"></a>

### 51. 构建乘积数组

给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素`B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]`。不能使用除法

```cpp
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> multiply(const vector<int>& A)
    {
        int n = (int)A.size();
        if (n == 0)
            return vector<int> ();
        vector<int> B(n,1);
        //存储i之前的数的乘积
        for (int i = 1;i < n ; i++)
            B[i] = B[i-1] * A[i-1];
        
        int tmp = 1;
        for (int i = n-2;i >=0; i--)
        {
            //tmp存储i之后的乘积
            tmp *= A[i+1];
            B[i] *= tmp;
        }
        return B;
    }
};
```

<a id="正则表达式匹配"></a>

### 52. 正则表达式匹配


请实现一个函数用来匹配包括`'.'`和`'*'`的正则表达式。模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但是与`"aa.a"`和`"ab*a"`均不匹配 

```cpp
/*
 如果模式串此时是'.',那么只需要模式串匹配串都往后移动一个位置
 如果现在这位的字符能匹配且模式串的下一位是'*',我们则需要分情况讨论
 1. 匹配串往后移动1位,模式串跳过'*'
 2. 匹配串往后移动1位,模式串不动
 3. 匹配串不动,模式串跳过'*'
 */

#include <iostream>

class Solution {
public:
    bool match(char* str,char* pattern)
    {
        if (str == NULL || pattern == NULL)
            return false;
        if (*str == '\0' && *pattern == '\0')
            return true;
        if (*str != '\0' && *pattern == '\0')
            return false;
        
        if (*(pattern+1)=='*')
        {
            if (*str == *pattern || (*str != '\0' && *pattern == '.'))
	            // *符号钱的字符出现次数  1 次 || 多次 || 0 次
                return match(str+1, pattern+2)||match(str+1, pattern)||match(str, pattern+2);
            return match(str, pattern+2);
        }
        if (*str==*pattern || (*pattern=='.' && *str!='\0'))
            return match(str+1, pattern+1);
        return false;
    }
};
```

<a id="表示数值的字符串"></a>

### 53. 表示数值的字符串

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

```cpp
#include <iostream>
using namespace std;

class Solution {
public:
    bool isNumeric(char* string)
    {
        if (string == NULL || *string == '\0')
            return false;
        if (*string == '+' || *string == '-')
            string ++;
        if (*string == '\0')
            return false;
        scanDigit(string);
        if (*string != '\0')
        {
            if (*string == '.')
            {
                string++;
                scanDigit(string);
                if (*string == 'e' || *string == 'E')
                    return isExponent(string);
            }
            else if (*string == 'e' || *string == 'E')
                return isExponent(string);
            else
                return false;
        }
        return *string == '\0' ? true : false;
    }
    
    //这里传 char *&str,引用的指针.是为了可以改变str指针的指向.在这里是引用传递.
    //形参: 函数定义时候的参数,形参在函数内是局部变量
    //实参: 函数调用时候传给被调用函数的参数
    //传值调用: 只使用了实参的值,形参是实参的一个副本
    //引用调用: 将是实参地址传给形参,从表面看是实参代替了形参.任何发生在形参的变化都作用在实参上
    void scanDigit(char*& str)
    {
        while (*str != '\0' && *str >= '0' && *str <= '9')
            str++;
    }
    
    bool isExponent(char*& str)
    {
        if (*str != 'e' && *str != 'E')
            return false;
        str++;
        if (*str=='+' || *str=='-')
            str++;
        if (*str == '\0')
            return false;
        scanDigit(str);
        return *str == '\0' ? true : false;
    }
};
```

<a id="字符流中第一个不重复的字符"></a>

### 54. 字符流中第一个不重复的字符

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"

输入描述：如果当前字符流没有存在出现一次的字符，返回#字符

```cpp
#include <string>
#include <vector>
using namespace std;

class Solution1
{
public:
    string str;
    //Insert one char from stringstream
    void Insert(char ch)
    {
        str += string(1,ch);
    }
    //return the first appearence once char in current stringstream
    char FirstAppearingOnce()
    {
        vector<int> hash(256,0); //char长度为8,所以256中可能
        char res = '#';
        int n = (int)str.length();
        for (int i = 0;i < n;i++)
        {
            if (hash[str[i]] == 0)
                hash[str[i]] = 1;
            else
                hash[str[i]] = -1;
        }
        for (int i = 0; i < n;i++)
        {
            if (hash[str[i]]==1)
            {
                res = str[i];
                break;
            }
        }
        return res;
    }
};
```

<a id="链表中环的入口结点"></a>

### 55. 链表中环的入口结点

一个链表中包含环，请找出该链表的环的入口结点
<div align="center">
<img src=https://raw.githubusercontent.com/LongPF/AtOffer/master/执行文件/55__链表中环的入口结点/55__链表中环的入口结点/有环的链表.png width="250" height = 125>
</div>


```cpp
#include <iostream>

/*
 解法1 :
 快慢指针,快指针每次走2个节点,慢指针每次走1个节点
 如图 相遇时候 fast走 a+b+c+b
 slow 走 a+b
 那么 2*(a+b) = a+b+c+b ==> a = c
 然后让fast指向head,fast和slow都每次走1个节点
 相遇点就是环的起始点
 */

struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x):
        val(x),next(NULL){}
};

class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        if (pHead == NULL)
            return NULL;
        ListNode* pSlow = pHead->next;
        ListNode* pFast = pHead->next;
        if (pFast)
            pFast = pFast->next;
        else
            return NULL;
        while (pFast && pSlow != pFast)
        {
            pSlow = pSlow->next;
            pFast = pFast->next;
            if (pFast)
                pFast = pFast->next;
            else
                break;
        }
        if (pSlow != pFast)
            return NULL;
        pFast = pHead;
        while (pFast != pSlow)
        {
            pFast = pFast->next;
            pSlow = pSlow->next;
        }
        return pFast;
    }
};

/*
 解法 2
 如果使用set的话思路就简单许多
 因为set不能插入相同的数,所以判断插入成功与否即可
 */
class Solution
{
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        if (pHead == NULL)
            return NULL;
        set<int> s;
        ListNode* n = pHead;
        while (n)
        {
            pair<set<int>::iterator, bool> p = s.insert(n->val);
            if (p.second == false)
                return n;
            n = n->next;
        }
        return NULL;
    }
};


```

<a id="删除链表中重复的结点"></a>

### 56. 删除链表中重复的结点

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 

例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

```cpp
#include <iostream>

using namespace std;

struct ListNode {
    int val;
    struct ListNode* next;
    ListNode(int x):
        val(x),next(NULL){}
};

class Solution
{
public:
    ListNode* deleteDuplication(ListNode*& pHead)
    {
        if (pHead == NULL)
            return NULL;
        ListNode* pre = NULL;
        ListNode* p = pHead;
        while (p != NULL && p->next != NULL)
        {
            if (p->val == p->next->val)
            {
                int key = p->val;
                while (p != NULL && p->val == key)
                {
                    ListNode* pToDelete = p;
                    p = p->next;
                    delete pToDelete;
                    pToDelete = NULL;
                }
                
                if (pre == NULL)
                    pHead = p;
                else
                    pre->next = p;
            }
            else
            {
                pre = p;
                p = p->next;
            }
        }
        return pHead;
    }
};
```

<a id="二叉树的下一个结点"></a>

### 57. 二叉树的下一个结点

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针

<div align="center">
<img src="https://github.com/LongPF/AtOffer/blob/master/执行文件/57__二叉树的下一个结点/57__二叉树的下一个结点/二叉树.png?raw=true" width="230" height="200">
</div>

```cpp
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {      
    }
};

class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if (pNode == NULL)
            return NULL;
        if (pNode->right)
        {
            pNode = pNode->right;
            while (pNode->left)
            {
                pNode = pNode->left;
            }
            return pNode;
        }
        TreeLinkNode* pParent = pNode->next;
        while (pParent != NULL && pParent->right == pNode)
        {
            pNode = pParent;
            pParent = pParent->next;
        }
        return pParent;
    }
};
```

<a id="对称的二叉树"></a>

### 58. 对称的二叉树

请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的

解法1 : 非递归

```cpp
#include <iostream>

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){}
};

bool isSymmetrical(TreeNode* pRoot){
    if (pRoot == NULL) return true;
    stack<TreeNode *> s1{};
    stack<TreeNode *> s2{};
    s1.push(pRoot);
    s2.push(pRoot);
    while (!s1.empty()&&!s2.empty()) {
        TreeNode *l = s1.top();
        TreeNode *r = s2.top();
        s1.pop();
        s2.pop();
        if (l == NULL && r == NULL) {
            continue;
        }else if (l == NULL || r == NULL){
            return false;
        }else if (l->val != r->val){
            return false;
        }else {
            if (l->left && r->right) {
                s1.push(l->left);
                s2.push(r->right);
            }else if ((l->left!=NULL&&r->right==NULL)||(l->left==NULL&&r->right!=NULL)){
                return false;
            }
            if (l->right && r->left) {
                s1.push(l->right);
                s2.push(r->left);
            }else if ((l->right!=NULL&&r->left==NULL)&&(l->right==NULL&&r->left!=NULL)){
                return false;
            }
        }
    }
    return true;
}
    
```

解法2 : 


```cpp
/*
 从根结点开始遍历
 如果左右有一个为NULL,那么可定不是对称二叉树
 如果左右子结点都不为空,但不相等,那么不是堆成二叉树
 如果左右子结点都不为空,但不相等,那么
 遍历左子树,遍历顺序为: 当前结点,左子树,右子树
 遍历右子树,遍历顺序为: 当前结点,右子树,左子树
 如果遍历左子树的序列和遍历右子树的序列一样,那么该二叉树为对称的二叉树
 */

class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
        if (pRoot == NULL)
            return true;
        return isSym(pRoot->left, pRoot->right);
    }
    bool isSym(TreeNode* pLeft,TreeNode* pRight)
    {
        if (pLeft == NULL && pRight == NULL)
            return true;
        if (pLeft == NULL || pRight == NULL)
            return false;
        if (pLeft->val != pRight->val)
            return false;
        return isSym(pLeft->left, pRight->right) && isSym(pLeft->right, pRight->left);
    }
};
```

<a id="把二叉树打印成多行"></a>

### 59. 把二叉树打印成多行

从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行

```cpp
#include <vector>
#include <queue>
using namespace std;

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){}
};

class Solution {
public:
    vector<vector<int>> Print(TreeNode* pRoot){
        vector<vector<int>> res;
        if (pRoot == NULL)
            return res;
        queue<TreeNode*>q;
        q.push(pRoot);
        int toBePrint = 1; //记录当前层还有几个未被打印
        int nextLevel = 0; //记录下一层有多少个需要被打印
        vector<int> numbers;
        while (!q.empty())
        {
            TreeNode* pNode = q.front();
            numbers.push_back(pNode->val);
            if (pNode->left)
            {
                q.push(pNode->left);
                ++nextLevel;
            }
            if (pNode->right)
            {
                q.push(pNode->right);
                ++nextLevel;
            }
            q.pop();
            toBePrint--;
            
            //当前层打印完成
            if (toBePrint == 0)
            {
                toBePrint = nextLevel;
                nextLevel = 0;
                res.push_back(numbers);
                numbers.clear();
            }
        }
        return res;
    }
};
```

<a id="按之字形顺序打印二叉树"></a>

### 60.按之字形顺序打印二叉树

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推

```cpp
#include <vector>
#include <stack>

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){};
};

class Solution {
public:
    vector<vector<int>> Print(TreeNode* pRoot)
    {
        vector<vector<int>> res;
        if (pRoot == NULL)
            return res;
        vector<int> numbers;
        stack<TreeNode*> odd,even; //奇偶栈
        odd.push(pRoot);
        while (!odd.empty() || !even.empty())
        {
            while (!odd.empty())
            {
                TreeNode* pNode = odd.top();
                numbers.push_back(pNode->val);
                //为下一层的偶数栈存数据
                if (pNode->left)
                    even.push(pNode->left);
                if (pNode->right)
                    even.push(pNode->right);
                odd.pop();
            }
            if (numbers.size() > 0)
            {
                res.push_back(numbers);
                numbers.clear();
            }
            while (!even.empty())
            {
                TreeNode* pNode = even.top();
                numbers.push_back(pNode->val);
                //为下一层的奇数栈存数据
                if (pNode->right)
                    odd.push(pNode->right);
                if (pNode->left)
                    odd.push(pNode->left);
                even.pop();
            }
            if (numbers.size()>0)
            {
                res.push_back(numbers);
                numbers.clear();
            }
        }
        return res;
    }
};
```

<a id="序列化二叉树"></a>

### 61. 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树 

这里需要注意下,堆空间对象释放问题

```cpp
#include <string>

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){};
};

class Solution {
public:
    char* Serialize(TreeNode* root){
        if (root==NULL) return "$";
        string str = to_string(root->val);
        str += ",";
        char *left = Serialize(root->left);
        str += left;
        if (*left!='$') delete left;
        char *right = Serialize(root->right);
        str += right;
        if (*right!='$') delete right;
        char *tmp = new char[str.size()+1];
        strcpy(tmp, str.c_str());
        return tmp;
    }
    
    TreeNode* Deserialize(char*& str){
        if (str==NULL) return NULL;
        if (*str=='$') {
            str++;
            return NULL;
        }
        int val = 0;
        while (*str!=',') {
            val = val*10+(*str-'0');
            str++;
        }
        str++;
        TreeNode *pRoot = new TreeNode(val);
        pRoot->left = Deserialize(str);
        pRoot->right = Deserialize(str);
        return pRoot;
    }
};
```


<a id="二叉搜索树的第k个结点"></a>

### 62. 二叉搜索树的第k个结点

给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4

解法1和解法2都是用一次中序二叉树遍历,解法1 非递归,解法2递归

解法1 :

```cpp
TreeNode* KthNode(TreeNode* pRoot,int k){
    if (pRoot==NULL||k<=0) return NULL;
    stack<TreeNode *>s{};
    TreeNode *p = pRoot;
    while (p || !s.empty()) {
        if (p) {
            s.push(p);
            p = p->left;
        }else{
            p = s.top();
            if (--k==0) return p;
            p = p->right;
            s.pop();
        }
    }
    return NULL;
}
```

解法2 :


```cpp
/*
 二叉搜索树的特点是左子结点小于根结点,根结点小于右子结点
 所以进行一次中序查找即可
 */

#include <iostream>

struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):
        val(x),left(NULL),right(NULL){}
};

class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot,int k)
    {
        if (pRoot == NULL || k <= 0)
        {
            return NULL;
        }
        return KthNodeCore(pRoot, k);
    }
    TreeNode* KthNodeCore(TreeNode* pRoot,int& k)
    {
        if (pRoot == NULL || k <=0)
            return NULL;
        TreeNode* res = NULL;
        if (pRoot->left != NULL)
            res = KthNodeCore(pRoot->left, k);
        if (res == NULL)
        {
            if (k == 1)
            {
                res = pRoot;
                return res;
            }
            k --;
        }
        //res!=NULL时候则找到了结果
        if (res == NULL && pRoot->right != NULL)
            res = KthNodeCore(pRoot->right, k);
        return res;
    }
};
```

<a id="数据流中的中位数"></a>

### 63. 数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值

两种建堆方式,multiset内部是红黑树,类似堆,优先队列

写法1

```cpp
/*
 头文件 #include <algorithm>
       #include <functional>
 make_heap()建立堆,把指定范围内的元素生成一个堆,默认建立的是最大堆,建最小堆的话第三个参数传greater<int>().
 push_heap()在堆中添加数据
 pop_heap()在堆中删除数据,将first和last-1的元素交换,然后重新生成一个堆.并没有真正删除.删除再pop_back
 sort_heap()堆排序
 
使用:
先建堆,

push: vector 先push_back ,再push_heap
pop: 先pop_heap,再 vector pop_back

sort_heap 没啥用
vector中的数据变化了 需要重新堆化, make_heap
 
 */

/*
 可以使用一个大根堆,一个小根堆配合
 为了实现平均分配,当前总数是偶数的时候插入小跟堆,奇数的时候插入大根堆.
 那么中位数就是最小堆的堆顶(插入前是偶数,插入后为奇数),或是两堆顶的平均值.
 */

#include <vector>
#include <algorithm> // sort
#include <functional> //greater
using namespace std;

class Solution {
public:
    void Insert(int num)
    {
        //偶
        if (((min.size()+max.size()) & 0x1)==0)
        {
            //为了保证新进入的流元素在插入最小堆的时候为最大堆的最大值,所以先插入最大堆并筛选下
            if (max.size() > 0 && max[0] > num)
            {
                max.push_back(num);
                push_heap(max.begin(), max.end(), less<int>());
                num = max[0];
                pop_heap(max.begin(), max.end(), less<int>());
                max.pop_back();
            }
            //插入到最小堆
            min.push_back(num);
            push_heap(min.begin(), min.end(), greater<int>());
        }
        //奇
        else
        {
            if (min.size() > 0 && min[0] < num)
            {
                min.push_back(num);
                push_heap(min.begin(), min.end(), greater<int>());
                num = min[0];
                pop_heap(min.begin(), min.end(), greater<int>());
                min.pop_back();
            }
            max.push_back(num);
            push_heap(max.begin(), max.end(), less<int>());
        }
    }
    
    double GetMedian()
    {
        if (((min.size()+max.size()) & 0x1)==1)
        {
            return min[0];
        }
        else
            return (max[0]+min[0]) / 2.0;
    }
    
private:
    vector<int> min; //小根堆
    vector<int> max; //大根堆
};
```


写法2

```cpp
class Solution {
    multiset<int,greater<int>> max;
    multiset<int,less<int>> min;
public:
    void Insert(int num)
    {
        if ((max.size()+min.size())%2==0) {
            int tmp = num;
            if (max.size() > 0 && *max.begin() > num) {
                max.insert(num);
                tmp = *max.begin();
                max.erase(max.begin());
            }
            min.insert(tmp);
        } else {
            int tmp = num;
            if (min.size() > 0 && *min.begin() < num) {
                min.insert(num);
                tmp = *min.begin();
                min.erase(min.begin());
            }
            max.insert(tmp);
        }
    }
    double GetMedian()
    { 
        if ((max.size()+min.size())%2==0){
            return (*min.begin()+*max.begin()) / 2.0;
        } else {
            return *min.begin();
        }
    }
};
```


<a id="滑动窗口的最大值"></a>

### 64. 滑动窗口的最大值

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}，{2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}


```cpp
/*
 这里用一个双向队列的方法
 最大值在队首,并保持从大到小的排列,每次新加入的从队尾到队首比较
 如果比队中已有的数大,则移除队
 每次移动要判断最大值(队首)元素是不是在有效范围内
 */

#include <vector>
#include <deque>

using namespace std;

class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num,unsigned int size)
    {
        vector<int> res;
        int n = (int)num.size();
        if (n == 0 || size == 0 || n < size)
            return res;
        int i;
        deque<int> index;
        for (i = 0; i < size;i ++)
        {
            //从队尾到队首比较大小
            while (!index.empty() && num[index.back()] <= num[i])
            {
                //如果新数比对尾数大 移除对尾元素
                index.pop_back();
            }
            //添加新数
            index.push_back(i);
        }
        res.push_back(num[index.front()]);
        for (i = size; i < n; i++)
        {
            //从队尾到队首比较大小
            while (!index.empty() && num[index.back()] <= num[i])
                index.pop_back();
            //判断队首元素是否在有效范围
            if (!index.empty() && i - index.front() >= size)
                index.pop_front();
            
            index.push_back(i);
            res.push_back(num[index.front()]);
        }
        return res;
    }
};
```

<a id="矩阵中的路径"></a>

### 65. 矩阵中的路径

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

例如
  
  ```
  a b c e 
  s f c s 
  a d e e
  ```
  
矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子

```cpp
/*
 这是一个回溯法的典型题.
 从一个任何一个点开始,下一个点可能位于该点的上下左右4个方位
 需要一个与输入矩阵同样大小的矩阵用来保存某个点是否被访问过
 由于回溯法的递归特性,路径可以被看成一个栈.当定位了前n个位置后,找不到第n+1个位置,
 则应该退回到第n-1个位置.
 */

#include <vector>

using namespace std;

class Solution {
public:
    bool hasPath(char* matrix,int rows,int cols,char* str)
    {
        if (matrix == NULL || rows < 1 || cols < 1 || str == NULL)
            return false;
        vector<bool> visited(rows*cols,0);
        int pathLength = 0;
        for (int row=0;row < rows;row++)
        {
            for(int col=0;col<cols;col++)
            {
                if (hasPathCore(matrix, rows, cols, row, col, str, pathLength, visited))
                    return true;
            }
        }
        return false;
    }
    
    bool hasPathCore(char* matrix,int rows,int cols,int row,int col,char* str,int& pathLenght,vector<bool>& visited)
    {
        //判断是否遍历寻找完毕
        if (str[pathLenght] == '\0')
            return true;
        bool res = false;
        if (row >= 0 && row < rows && col >=0 && col < cols &&
            matrix[row*cols+col]==str[pathLenght] && !visited[row*cols+col])
        {
            visited[row*cols+col] = true;
            ++pathLenght;
            //上下左右 寻找下一个位置
            res = hasPathCore(matrix, rows, cols, row, col-1, str, pathLenght, visited) ||
                  hasPathCore(matrix, rows, cols, row, col+1, str, pathLenght, visited) ||
                  hasPathCore(matrix, rows, cols, row-1, col, str, pathLenght, visited) ||
                  hasPathCore(matrix, rows, cols, row+1, col, str, pathLenght, visited) ;
            //如果找不到下一个位置,则退回
            if (!res)
            {
                visited[row*cols+col] = false;
                pathLenght--;
            }
        }
        return res;
    }
};
```

<a id="机器人的运动范围"></a>

### 66. 机器人的运动范围

地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子

<div align=center>
<img src="https://github.com/LongPF/AtOffer/blob/master/执行文件/66__机器人的运动范围/66__机器人的运动范围/K=4-RES=15.png?raw=true" width=180 height=180>
</div>

```cpp
/*
 K=4,格子数为15,如图黄色区域
 回溯法,机器人从(0,0)开始移动,当移动到下一个位置时候
 通过格子数位和判断是否可以进入
 如果可以进入则判断其上下左右4个相邻位置是否可以进入
 */

#include <vector>

using namespace std;

class Solution {
public:
    
    int movingCount(int threshold,int rows,int cols)
    {
        if (threshold <0 || rows < 1 || cols < 1)
            return 0;
        vector<bool> visited(rows*cols,0);
        int res= movingCore(threshold, rows, cols, 0, 0, visited);
        return res;
    }
    
    int movingCore(int threshold,int rows,int cols,int row,int col,vector<bool>& visited)
    {
        int res = 0;
        if (canMove(threshold, rows, cols, row, col) && !visited[row*cols+col])
        {
            visited[row*cols+col] = true;
            res = 1 + movingCore(threshold, rows, cols, row, col-1, visited) +
                    movingCore(threshold, rows, cols, row, col+1, visited) +
                    movingCore(threshold, rows, cols, row-1, col, visited) +
                    movingCore(threshold, rows, cols, row+1, col, visited);
        }
        
        return res;
    }
    
    bool canMove(int threshold,int rows,int cols,int row,int col)
    {
        int sum = 0;
        if (row >= 0 && row < rows && col >= 0 && col < cols)
        {
            while (row)
            {
                sum += row % 10;
                row /= 10;
            }
            while (col)
            {
                sum += col % 10;
                col /= 10;
            }
            if (sum <= threshold)
                return true;
            return false;
        }
        return false;
    }
};
```